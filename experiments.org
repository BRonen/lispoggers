
* Closure Elimination: lambda lifting

By lifting the lambdas to become static functions, the process of compiling functions into imperative bytecode gets simple.

#+BEGIN_SRC js

// using only lambdas

const _1 = (add5 => add5(3)) (y => 5 + y);
console.log(_1); // -> 8

// using only static functions

function $1 (y) {
    return 5 + y;
}

function $2 () {
  return $1(3);
}

const _2 = $2();
console.log(_2);  // -> 8

#+END_SRC

#+RESULTS:
: 8
: 8
: undefined


* Bytecode

The initial concept of the virtual machine will be stack-based:

#+BEGIN_SRC kekw
pushInt 3

label teste
pushInt 2
add

debug

pushInt 12
cmp
pop
ltF
jump teste

debug
#+END_SRC

#+RESULTS:
#+begin_example
=== Debug ===
stack: [Int(5)]
labels: {"teste": 1}
lt: false
eq: false
=== Debug ===
=== Debug ===
stack: [Int(7)]
labels: {"teste": 1}
lt: true
eq: false
=== Debug ===
=== Debug ===
stack: [Int(9)]
labels: {"teste": 1}
lt: true
eq: false
=== Debug ===
=== Debug ===
stack: [Int(11)]
labels: {"teste": 1}
lt: true
eq: false
=== Debug ===
=== Debug ===
stack: [Int(13)]
labels: {"teste": 1}
lt: true
eq: false
=== Debug ===
=== Debug ===
stack: [Int(13)]
labels: {"teste": 1}
lt: false
eq: false
=== Debug ===

Process kekw finished
#+end_example

* Org Babel Extension

#+BEGIN_SRC elisp
(defun org-babel-execute:kekw (body params)
  (let* ((command '("env" "RUSTFLAGS=-Awarnings" "cargo" "run" "--quiet"))
         (output (with-temp-buffer
                   (let ((proc (make-process
                                :name "kekw"
                                :buffer (current-buffer)
                                :command command
                                :connection-type 'pipe)))
                     (process-send-string proc body)
                     (process-send-eof proc)
                     (while (accept-process-output proc))
                     (buffer-string)))))
    output))
#+END_SRC

#+RESULTS:
: org-babel-execute:kekw
